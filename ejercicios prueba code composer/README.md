| Project Name | Functional description |
|---|---|
| CD141220-display.c | This code is a C program for a Texas Instruments TM4C1294NCPDT microcontroller that interfaces with a 16x2 LCD display. The code defines several functions to initialize the display, send commands and data, and check the busy flag status of the display. The INILCD function initializes the display to use an 8-bit, 2-line, 5x7 character interface. It also turns on the display with cursor and flash, clears the display content, and sets the behavior of the cursor to increment and scroll when typing. The ESCCOM and ESCDAT functions send commands and data to the display, respectively. These functions use the "E" function to generate a pulse at the E terminal of the display and send the command or data. The BUSY function checks the status of the busy flag on the display and waits until it is zero. This function uses the LEECON function to read the value of the display control register and check if the busy flag is active. |
| CODPRAC9.C | This code is designed to run on a Tiva C board model TM4C1294NCPDT and uses various peripherals including GPIOs, timers, and ADCs. At the beginning of the code, the necessary libraries are included and some constants and variables are defined. Then, in the main function, the GPIO ports N, D and E are enabled and timer 3 is enabled. The clock for the ADC is also enabled and an initial value is set for the variable ValorADC. After that, the terminal of the module T3CCP0 and T3CCP1 corresponding to PD4 (T3CCP0) and PD5 (T3CCP1) is configured. Bit 4 is enabled as digital and configured as an output. The alternate function is also set in bit 4 and goes to T3CCP0. Finally, timer 3 is disabled during configuration and set to 16-bit PWM mode with periodic count down. Then, the reload and match values for timer 3 are set and timers A and B are enabled. The clock is also set to 16 MHz. After that, PLLFREQ1 and PLLFREQ0 are set and wait for bit 0 of the PLLSTAT register is 1. Next, PE.4 is initialized to be AIN9 and the analog module on PE3 and PE4 is enabled. The digital buffer on those ports is also disabled. Finally, port N is prepared to signal the input voltage with LEDs 0 and 1. After that, the ADC is initialized and the priorities and sample rate are configured. Sequencers are also disabled during setup and set to start the conversion by software. The SSEMUX3 and SSMUX3 are then configured to input the first group of 16 channels (0 through 15) and channel 9, respectively. The SSEMUX2 and SSMUX2 are also configured to obtain the input of the first group of 16 channels (0 to 15) and of channel 0, respectively. After that, a flag to finish at first sample is set in SSCTL3 and SSCTL2 and ADC0 sequencer 3 is enabled. Finally, the PLL is disabled and an infinite loop is entered. Within the infinite loop, conversion sequence 3 is started and waited for it to complete. The result of the conversion is then read and assigned to the variable ValueADC, which is then used to set the matching value of TIMER3_TAMATCHR. After that, the flag is cleared and conversion sequence 2 is started. It waits for it to complete and then the result of the conversion is read and assigned to the variable ADCValue, which is then used to set the match value. from TIMER3_TBMATCHR. Finally, the flag for sequencer 2 is cleared and the infinite loop continues. In summary, this code configures and initializes various peripherals on a Tiva C board model TM4C1294NCPDT and implements an infinite loop that performs ADC conversions using two different sequencers. The results of the conversions are then used to update the match values on two different timers. |
| SU-HCSR04 distance meter.txt | This code is a template for an ultrasonic sensor using a Tiva C board model tm4c1294ncpdt. The code includes several functions to initialize and configure port N, timer 3, and UART0. The `TRIGGER_04` function generates a pulse on pin PN4 to activate the ultrasonic sensor. The duration of the pulse is determined by the variable `x`. The `PORTN_INI` function initializes port N and configures pins PN4 and PN5 as digital input and output, respectively. The `TIMER_INI` function initializes timer 3 and sets it to count up in periodic mode with a reload value of 0X00FFFFFF. The `UART_INI` function initializes UART0 and configures it for serial communication with a baud rate of 115200 baud. The functions `UART_Read_data` and `UART0_Write e_data` are used to read and write data through the UART0. In the `main` function, UART0, port N, and timer 3 are initialized. Then, in an infinite loop, the `TRIGGER_04` function is called to generate a pulse on pin PN4 and activate the ultrasonic sensor. It waits for pin PN5 to go high before enabling timer 3. When pin PN5 goes low again, timer 3 is disabled. The value of timer 3 at this point can be used to calculate the distance measured by the ultrasonic sensor . There is another infinite loop at the end of the code, in this loop, a distance value is written through the UART0. Regarding electronic devices used in this code, it can be inferred that an ultrasonic sensor connected to pins PN4 and PN5 of the Tiva C board is being used. UART0 is also being used for serial communication. |
| adc-pwm.c | This code appears to be a program for a Tiva C microcontroller model tm4c1294ncpdt that uses an ADC to read sensor values and control a servo motor using PWM. The code starts by including the `stdbool.h` and `stdint.h` libraries and a specific header file for the `tm4c1294ncpdt.h` microcontroller model. Then, it defines two values for `ValPLLFREQ0` and `ValPLLFREQ1` and three global variables: `ValueADC`, `ui32Loop` and `ValueADCf`. The main function `main` starts by enabling ports N and D in the `SYSCTL_RCGCGPIO_R` register and enabling timer 3 in the `SYSCTL_RCGCTIMER_R` register. Then there is a delay to allow the clock to reach ports N and D and timer 3. Then the T3CCP0 module pin corresponding to PD4 is set. Bit 4 is enabled as digital and configured as an output. The alternate function is also set in bit 4 and goes to T3CCP0. Then, timer 3 is disabled during configuration and set to 16-bit periodic countdown PWM mode. Values are set for the `TIMER3_TAILR_R`, `TIMER3_TAMATCHR_R` and `TIMER3_TAPR_R` registers and finally Timer A is enabled. After setting the timer, values are set for the `SYSCTL_PLLFREQ1_R` and `SYSCTL_PLLFREQ0_R` registers using the constants defined above ` ValPLLFREQ1` and `ValPLLFREQ0`. Then, there is a while loop that waits for bit 0 of the `SYSCTL_PLLSTAT_R` register to be 1. Clock is then enabled for ports E and N and for the ADC in the `SYSCTL_RCGCGPIO_R` and `SYSCTL_RCGCADC_R` registers. Then the PE.3 pin is initialized to be AIN0 enabling the analog module and disabling the digital buffer. Finally, port N is prepared to signal the input voltage by setting the `GPIO_PORTN_DATA_R`, `GPIO_PORTN_DEN_R` and `GPIO_PORTN_DIR_R` registers. After preparing the ports, the code initializes the ADC. First, the `ADC0_SSPRI_R` registry value is set to maintain the same priorities. Then, the sample rate is set in the `ADC0_PC_R` register and all sequencers are disabled during configuration in the `ADC0_ACTSS_R` register. Next, the start of the soft conversion is set in the `ADC0_EMUX_R` register and the input of the first group of 16 channels is obtained in the `ADC0_SSEMUX3_R` register. Next, the channel 0 entry is obtained in the `ADC0_SSMUX3_R` register and a flag to terminate at the first sample is set in the `ADC0_SSCTL3_R` register. Finally, ADC0 sequencer 3 is enabled in the `ADC0_ACTSS_R` register. Then, there is an infinite while loop that begins a conversion sequence in the `ADC0_PSSI_R` register and waits for the conversion to complete in the `ADC0_RIS_R` register. After the conversion is complete, the result of the conversion is read into the `ADC0_SSFIFO3_R` register and the value of the `TIMER3_TAMATCHR_R` register is set to the read value. Finally, the flag in the `ADC0_ISC_R` register is cleared. After the infinite while loop, there is another empty infinite while loop, and then the main function ends. In summary, this code seems to use an ADC to read values from a sensor connected to the PE.3 pin of the microcontroller. |
| adc.c | This code is written in C for a Tiva C development board model tm4c1294ncpdt and is used to control the board's LEDs based on the input voltage on pin AIN0 (PE3), which is connected to a potentiometer. The code starts by including the necessary libraries and by defining some constants. Then, two global variables ValueADC and ValueADCf are declared. In the main function, the system clock is configured and the clock is enabled for ports E and N and for the ADC. The PE.3 pin is also initialized to be AIN0 and port N is prepared to signal the input voltage. The ADC is then initialized and configured to have a sample rate of 1Ms/S . Sequencer 3 is then disabled during setup and configured so that the conversion is soft-initiated and input from channel 0 is obtained. After enabling sequencer 3, the code enters an infinite loop starting a conversion sequence and waits for it to complete. After the conversion is complete, the result is read and stored in the variable ADCValue. Then, based on the value of ValueADC, the value of port N is set. Finally, the value of ValueADC is converted to degrees and the flag is cleared. In summary, this code reads the value of the potentiometer connected to pin AIN0 (PE3) through the ADC and turns on the LEDs of port N based on the value read. |
| hc05.c | This code is designed to run on a Tiva C microcontroller model TM4C1294NCPDT and configures two UART modules (UART0 and UART3) for serial communication. The `UART_INI` function initializes the UART0 and UART3 modules with different baud rates and configures the port A GPIO pins for use with the UART modules. The `UART_Read_data` and `UART3_Read_data` functions wait for data to be received in the UART0 and UART3 modules respectively and then store it in the global variable `d_uint8Data`. The `UART0_Write_data` function takes a character as input and sends it through the UART0 module. This code is designed to work with a HC-05 Bluetooth module, one of the UART modules (UART3) is connected to the HC-05 module for serial communication. In this case, the code would read data sent from a device connected to the HC-05 module via Bluetooth using the `UART3_Read_data` function. The code would then increment each character by one and send it through the UART0 module using the `UART0_Write_data` function. In the `main` function, the system clock frequency is set and the `UART_INI` function is called to initialize the UART modules. Then, in an infinite loop, the `UART3_Read_data` function is called to read a character from the UART3 module (connected to the HC-05 module) and then the `UART0_Write_data` function is called to send that character plus one through the module UART0. In short, this code could be used to receive data from a device connected via Bluetooth using an HC-05 module, increment each character by one, and then send the changed data through the UART0 module. |
| main.c | This code is designed to run on a Tiva C microcontroller model TM4C1294NCPDT and control a servo motor using a timer in PWM (Pulse Width Modulation) mode. The code starts by setting the system clock and enabling the clock for ports E, D, and N. It also enables the clock for the ADC (Analog-to-Digital Converter) module and configures the PE3 pin to function as an analog input (AIN0). Timer 3 is set to run in PWM mode and is used to control the servo motor. The timer reload value is set to 0xfff and the compare register is initially set to 0x3ff. The PD4 pin is configured as an output and the alternate function T3CCP0 is selected so that the timer can control the state of the pin. The code also initializes the PN0 and PN1 pins to function as digital outputs and can be used to signal input voltage. The ADC module is configured to take samples of the analog signal on pin AIN0 (PE3) and convert them to digital values. The digital value resulting from the conversion is used to update the timer comparison register (TIMER3_TAMATCHR_R), which affects the width of the pulse generated by the timer in PWM mode. The code is in an infinite loop that continually starts a new ADC conversion and updates the timer compare register with the result of the conversion. This allows the width of the pulse generated by the timer to change dynamically based on the analog signal on the AIN0 pin. In short, this code is using a timer in PWM mode to control a servo motor and adjust its position based on an analog signal measured by the ADC module. |
| timers.c | This code is written in C for the Tiva C Series TM4C1294NCPDT microcontroller and appears to be designed to drive an LED connected to bit 0 of port N (PN0). The code begins by including the necessary libraries and by defining the functions `complement0`, `complement1`, `Timer03AIntHandler` and `Timer03BIntHandler`. The functions `complement0` and `complement1` use XOR operations to change the state of bits 0 and 1 of the port N data register (GPIO_PORTN_DATA_R), respectively. The `Timer03AIntHandler` and `Timer03BIntHandler` functions are interrupt handlers for timers A and B of timer 3. Both functions clear the interrupt flag of timer 3 and Then they call the functions `complement0` and `complement1`, respectively. The main function `main` starts by enabling port N and timer 3. It then sets timer 3 as a 32-bit timer in periodic mode and counts up. It also configures bit 0 of port N as a digital output. After setting timer 3 and port N, the code goes into an infinite loop. Within this loop, there is another loop that checks bit 0 of the Timer 3 interrupt status register (TIMER3_RIS_R). If this bit is 0, the loop continues. If this bit is 1, the loop breaks and the code clears the timer 3 interrupt flag and then changes the state of port N data register bit 0 (GPIO_PORTN_DATA_R) using an XOR operation. This causes the LED connected to PN0 to blink at a rate determined by the reload value of timer 3. After this inner loop, the code enters another infinite loop that does nothing. In short, this code sets up a timer to blink an LED connected to bit 0 of port N at a rate determined by the reload value of the timer. |
| uart.c | This code is written in C for the Tiva C microcontroller model TM4C1294NCPDT. The code includes the standard C libraries and the microcontroller-specific libraries for its operation. The `UART_INI` function initializes the UART0 of the microcontroller. It first enables UART0 and port A. It then configures the UART control registers to set the baud rate and other parameters such as the number of data bits and FIFO usage. Finally, configure the port A pins for use with the UART. The `UART_Read_data` function waits for data to be received on the UART and then reads it and stores it in the global variable `d_uint8Data`. The `UART0_Write_data` function waits for the UART transmit register to be empty and then writes the data passed as an argument to it. The `main` function initializes the system clock and calls the `UART_INI` function to initialize the UART. It then goes into an infinite loop where it reads some data from the UART and then writes it back to the UART. |


