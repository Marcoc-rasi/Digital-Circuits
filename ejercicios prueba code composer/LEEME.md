| Nombre del Proyecto | Descripción de funcionamiento |
|---|---|
| # CD141220-display.c | Este código es un programa en C para un microcontrolador TM4C1294NCPDT de Texas Instruments que interactúa con un display LCD de 16x2. El código define varias funciones para inicializar el display, enviar comandos y datos, y verificar el estado de la bandera de ocupado del display. La función INILCD inicializa el display para usar una interfaz de 8 bits, 2 líneas y caracteres de 5x7. También enciende el display con cursor y destello, borra el contenido del display y configura el comportamiento del cursor para que se incremente y se desplace al escribir. Las funciones ESCCOM y ESCDAT envían comandos y datos al display, respectivamente. Estas funciones utilizan la función _E para generar un pulso en la terminal E del display y enviar el comando o dato. La función BUSY verifica el estado de la bandera de ocupado del display y espera hasta que sea cero. Esta función utiliza la función LEECON para leer el valor del registro de control del display y verificar si la bandera de ocupado está activa.  |

| # CODPRAC9.C | Este código está diseñado para ejecutarse en una placa Tiva C modelo TM4C1294NCPDT y utiliza varios periféricos, incluidos GPIO, temporizadores y ADC. Al principio del código, se incluyen las bibliotecas necesarias y se definen algunas constantes y variables. Luego, en la función main, se habilitan los puertos N, D y E del GPIO y el temporizador 3. También se habilita el reloj para el ADC y se configura un valor inicial para la variable ValorADC. Después de eso, se configura la terminal del módulo T3CCP0 y T3CCP1 correspondiente a PD4 (T3CCP0) y PD5 (T3CCP1). Se habilita el bit 4 como digital y se configura como salida. También se establece la función alternativa en el bit 4 y se dirige a T3CCP0. Finalmente, se deshabilita el temporizador 3 durante la configuración y se configura para 16 bits en modo PWM con cuenta periódica hacia abajo. Luego, se configuran los valores de recarga y coincidencia para el temporizador 3 y se habilitan los temporizadores A y B. También se establece el reloj a 16 MHz. Después de eso, se configura el PLLFREQ1 y PLLFREQ0 y se espera a que el bit 0 del registro PLLSTAT sea 1. A continuación, se inicializa PE.4 para que sea AIN9 y se habilita el módulo analógico en PE3 y PE4. También se deshabilita el buffer digital en esos puertos. Finalmente, se prepara el puerto N para señalizar la entrada de voltaje con los LED 0 y 1. Después de eso, se inicializa el ADC y se configuran las prioridades y la velocidad de muestreo. También se deshabilitan los secuenciadores durante la configuración y se establece el inicio de la conversión por software. Luego, se configura el SSEMUX3 y SSMUX3 para obtener la entrada del primer grupo de 16 canales (0 al 15) y del canal 9, respectivamente. También se configura el SSEMUX2 y SSMUX2 para obtener la entrada del primer grupo de 16 canales (0 al 15) y del canal 0, respectivamente. Después de eso, se establece una bandera para terminar a la primera muestra en SSCTL3 y SSCTL2 y se habilita el secuenciador 3 del ADC0. Finalmente, se deshabilita el PLL y se entra en un bucle infinito. Dentro del bucle infinito, se inicia la secuencia de conversión 3 y se espera a que se complete. Luego, se lee el resultado de la conversión y se asigna a la variable ValorADC, que luego se utiliza para establecer el valor de coincidencia de TIMER3_TAMATCHR. Después de eso, se limpia la bandera y se inicia la secuencia de conversión 2. Se espera a que se complete y luego se lee el resultado de la conversión y se asigna a la variable ValorADC, que luego se utiliza para establecer el valor de coincidencia de TIMER3_TBMATCHR. Finalmente, se limpia la bandera para el secuenciador 2 y el bucle infinito continúa. En resumen, este código configura e inicializa varios periféricos en una placa Tiva C modelo TM4C1294NCPDT e implementa un bucle infinito que realiza conversiones ADC utilizando dos secuenciadores diferentes. Los resultados de las conversiones luego son utilizados para actualizar los valores de coincidencia en dos temporizadores diferentes. |

| # SU-HCSR04 medidor de distancia.txt | Este código es una plantilla para un sensor ultrasónico utilizando una placa Tiva C modelo tm4c1294ncpdt. El código incluye varias funciones para inicializar y configurar el puerto N, el temporizador 3 y la UART0. La función `TRIGGER_04` genera un pulso en el pin PN4 para activar el sensor ultrasónico. La duración del pulso está determinada por la variable `x`. La función `PORTN_INI` inicializa el puerto N y configura los pines PN4 y PN5 como salida y entrada digital, respectivamente. La función `TIMER_INI` inicializa el temporizador 3 y lo configura para contar hacia arriba en modo periódico con un valor de recarga de 0X00FFFFFF. La función `UART_INI` inicializa la UART0 y la configura para comunicación serial con una velocidad de transmisión de 115200 baudios. Las funciones `UART_Lee_dato` y `UART0_Escribe_dato` se utilizan para leer y escribir datos a través de la UART0. En la función `main`, se inicializan la UART0, el puerto N y el temporizador 3. Luego, en un bucle infinito, se llama a la función `TRIGGER_04` para generar un pulso en el pin PN4 y activar el sensor ultrasónico. Se espera a que el pin PN5 sea alto antes de habilitar el temporizador 3. Cuando el pin PN5 vuelve a ser bajo, se deshabilita el temporizador 3. El valor del temporizador 3 en este punto puede utilizarse para calcular la distancia medida por el sensor ultrasónico. Hay otro bucle infinito al final del código, en este bucle, se escribe un valor de distancia a través de la UART0. En cuanto a dispositivos electrónicos utilizados en este código, se puede inferir que se está utilizando un sensor ultrasónico conectado a los pines PN4 y PN5 de la placa Tiva C. También se está utilizando la UART0 para comunicación serial. |

| # adc-pwm.c | Este código parece ser un programa para un microcontrolador Tiva C modelo tm4c1294ncpdt que utiliza un ADC para leer valores de un sensor y controlar un servomotor utilizando PWM. El código comienza incluyendo las bibliotecas `stdbool.h` y `stdint.h` y un archivo de encabezado específico para el modelo de microcontrolador `tm4c1294ncpdt.h`. Luego, define dos valores para `ValPLLFREQ0` y `ValPLLFREQ1` y tres variables globales: `ValorADC`, `ui32Loop` y `ValorADCf`. La función principal `main` comienza habilitando los puertos N y D en el registro `SYSCTL_RCGCGPIO_R` y habilitando el temporizador 3 en el registro `SYSCTL_RCGCTIMER_R`. Luego, hay un retardo para permitir que el reloj alcance los puertos N y D y el temporizador 3. Después, se configura la terminal del módulo T3CCP0 correspondiente a PD4. Se habilita el bit 4 como digital y se configura como salida. También se establece la función alternativa en el bit 4 y se dirige a T3CCP0. Luego, se deshabilita el temporizador 3 durante la configuración y se configura para 16 bits en modo PWM periódico con cuenta descendente. Se establecen valores para los registros `TIMER3_TAILR_R`, `TIMER3_TAMATCHR_R` y `TIMER3_TAPR_R` y finalmente se habilita el temporizador A. Después de configurar el temporizador, se establecen valores para los registros `SYSCTL_PLLFREQ1_R` y `SYSCTL_PLLFREQ0_R` utilizando las constantes definidas anteriormente `ValPLLFREQ1` y `ValPLLFREQ0`. Luego, hay un bucle while que espera a que el bit 0 del registro `SYSCTL_PLLSTAT_R` sea 1. A continuación, se habilita el reloj para los puertos E y N y para el ADC en los registros `SYSCTL_RCGCGPIO_R` y `SYSCTL_RCGCADC_R`. Luego, se inicializa el pin PE.3 para que sea AIN0 habilitando el módulo analógico y deshabilitando el buffer digital. Finalmente, se prepara el puerto N para señalizar la entrada de voltaje configurando los registros `GPIO_PORTN_DATA_R`, `GPIO_PORTN_DEN_R` y `GPIO_PORTN_DIR_R`. Después de preparar los puertos, el código inicializa el ADC. Primero, se establece el valor del registro `ADC0_SSPRI_R` para mantener las mismas prioridades. Luego, se establece la velocidad de la muestra en el registro `ADC0_PC_R` y se deshabilitan todos los secuenciadores durante la configuración en el registro `ADC0_ACTSS_R`. Después, se configura el inicio de la conversión por software en el registro `ADC0_EMUX_R` y se obtiene la entrada del primer grupo de 16 canales en el registro `ADC0_SSEMUX3_R`. Luego, se obtiene la entrada del canal 0 en el registro `ADC0_SSMUX3_R` y se establece una bandera para terminar a la primera muestra en el registro `ADC0_SSCTL3_R`. Finalmente, se habilita el secuenciador 3 del ADC0 en el registro `ADC0_ACTSS_R`. Luego, hay un bucle while infinito que comienza una secuencia de conversión en el registro `ADC0_PSSI_R` y espera a que la conversión se complete en el registro `ADC0_RIS_R`. Después de que la conversión se completa, se lee el resultado de la conversión en el registro `ADC0_SSFIFO3_R` y se establece el valor del registro `TIMER3_TAMATCHR_R` con el valor leído. Finalmente, se limpia la bandera en el registro `ADC0_ISC_R`. Después del bucle while infinito, hay otro bucle while infinito vacío y luego termina la función principal. En resumen, este código parece utilizar un ADC para leer valores de un sensor conectado al pin PE.3 del microcontrolador. |

| # adc.c | Este código está escrito en C para una placa de desarrollo Tiva C modelo tm4c1294ncpdt y se utiliza para controlar los LEDs de la tarjeta en función del voltaje de entrada en el pin AIN0 (PE3), que está conectado a un potenciómetro. El código comienza incluyendo las bibliotecas necesarias y definiendo algunas constantes. Luego, se declaran dos variables globales ValorADC y ValorADCf. En la función main, se configura el reloj del sistema y se habilita el reloj para los puertos E y N y para el ADC. También se inicializa el pin PE.3 para que sea AIN0 y se prepara el puerto N para señalizar la entrada de voltaje. A continuación, se inicializa el ADC y se configura para que tenga una velocidad de muestra de 1Ms/S. Luego, se deshabilita el secuenciador 3 durante la configuración y se configura para que la conversión se inicie por software y se obtenga la entrada del canal 0. Después de habilitar el secuenciador 3, el código entra en un bucle infinito en el que se inicia una secuencia de conversión y se espera a que se complete. Una vez completada la conversión, se lee el resultado y se almacena en la variable ValorADC. Luego, según el valor de ValorADC, se establece el valor del puerto N. Finalmente, se convierte el valor de ValorADC a grados y se limpia la bandera. En resumen, este código lee el valor del potenciómetro conectado al pin AIN0 (PE3) mediante el ADC y enciende los LEDs del puerto N en función del valor leído. |

| # hc05.c | Este código está diseñado para ejecutarse en un microcontrolador Tiva C modelo TM4C1294NCPDT y configura dos módulos UART (UART0 y UART3) para la comunicación serial. La función `UART_INI` inicializa los módulos UART0 y UART3 con diferentes velocidades de transmisión (baud rate) y configura los pines GPIO del puerto A para su uso con los módulos UART. Las funciones `UART_Lee_dato` y `UART3_Lee_dato` esperan a que se reciba un dato en los módulos UART0 y UART3 respectivamente y luego lo almacenan en la variable global `d_uint8Dato`. La función `UART0_Escribe_dato` toma un carácter como entrada y lo envía a través del módulo UART0. Este código está diseñado para funcionar con un módulo Bluetooth HC-05, uno de los módulos UART (UART3) esté conectado al módulo HC-05 para la comunicación serial. En este caso, el código leería datos enviados desde un dispositivo conectado al módulo HC-05 a través de Bluetooth utilizando la función `UART3_Lee_dato`. Luego, el código incrementaría cada carácter en uno y lo enviaría a través del módulo UART0 utilizando la función `UART0_Escribe_dato`. En la función `main`, se configura la frecuencia del reloj del sistema y se llama a la función `UART_INI` para inicializar los módulos UART. Luego, en un bucle infinito, se llama a la función `UART3_Lee_dato` para leer un carácter del módulo UART3 (conectado al módulo HC-05) y luego se llama a la función `UART0_Escribe_dato` para enviar ese carácter más uno a través del módulo UART0. En resumen, este código podría usarse para recibir datos de un dispositivo conectado a través de Bluetooth utilizando un módulo HC-05, incrementar cada carácter en uno y luego enviar los datos modificados a través del módulo UART0. |

| # main.c | Este código está diseñado para ejecutarse en un microcontrolador Tiva C modelo TM4C1294NCPDT y controlar un servomotor utilizando un temporizador en modo PWM (modulación por ancho de pulso). El código comienza configurando el reloj del sistema y habilitando el reloj para los puertos E, D y N. También habilita el reloj para el módulo ADC (convertidor analógico a digital) y configura el pin PE3 para que funcione como entrada analógica (AIN0). El temporizador 3 se configura para funcionar en modo PWM y se utiliza para controlar el servomotor. El valor de recarga del temporizador se establece en 0xfff y el registro de comparación se establece inicialmente en 0x3ff. El pin PD4 se configura como salida y se selecciona la función alternativa T3CCP0 para que el temporizador pueda controlar el estado del pin. El código también inicializa los pines PN0 y PN1 para que funcionen como salidas digitales y puedan ser utilizados para señalizar la entrada de voltaje. El módulo ADC se configura para tomar muestras de la señal analógica en el pin AIN0 (PE3) y convertirlas en valores digitales. El valor digital resultante de la conversión se utiliza para actualizar el registro de comparación del temporizador (TIMER3_TAMATCHR_R), lo que afecta el ancho del pulso generado por el temporizador en modo PWM. El código está en un bucle infinito que continuamente inicia una nueva conversión ADC y actualiza el registro de comparación del temporizador con el resultado de la conversión. Esto permite que el ancho del pulso generado por el temporizador cambie dinámicamente en función de la señal analógica en el pin AIN0. En resumen, este código está utilizando un temporizador en modo PWM para controlar un servomotor y ajustar su posición en función de una señal analógica medida por el módulo ADC.  |

| # timers.c | Este código está escrito en C para el microcontrolador Tiva C Series TM4C1294NCPDT y parece estar diseñado para controlar un LED conectado al bit 0 del puerto N (PN0). El código comienza incluyendo las bibliotecas necesarias y definiendo las funciones `complementa0`, `complementa1`, `Timer03AIntHandler` y `Timer03BIntHandler`. Las funciones `complementa0` y `complementa1` utilizan operaciones XOR para cambiar el estado de los bits 0 y 1 del registro de datos del puerto N (GPIO_PORTN_DATA_R), respectivamente. Las funciones `Timer03AIntHandler` y `Timer03BIntHandler` son manejadores de interrupción para los temporizadores A y B del temporizador 3. Ambas funciones limpian la bandera de interrupción del temporizador 3 y luego llaman a las funciones `complementa0` y `complementa1`, respectivamente. La función principal `main` comienza habilitando el puerto N y el temporizador 3. Luego configura el temporizador 3 como un temporizador de 32 bits en modo periódico y cuenta hacia arriba. También configura el bit 0 del puerto N como salida digital. Después de configurar el temporizador 3 y el puerto N, el código entra en un bucle infinito. Dentro de este bucle, hay otro bucle que verifica el bit 0 del registro de estado de interrupción del temporizador 3 (TIMER3_RIS_R). Si este bit es 0, el bucle continúa. Si este bit es 1, el bucle se rompe y el código limpia la bandera de interrupción del temporizador 3 y luego cambia el estado del bit 0 del registro de datos del puerto N (GPIO_PORTN_DATA_R) utilizando una operación XOR. Esto hace que el LED conectado a PN0 parpadee a una velocidad determinada por el valor de recarga del temporizador 3. Después de este bucle interno, el código entra en otro bucle infinito que no hace nada. En resumen, este código configura un temporizador para hacer parpadear un LED conectado al bit 0 del puerto N a una velocidad determinada por el valor de recarga del temporizador. |

| # uart.c | Este código está escrito en C para el microcontrolador Tiva C modelo TM4C1294NCPDT. El código incluye las bibliotecas estándar de C y las bibliotecas específicas del microcontrolador para su funcionamiento. La función `UART_INI` inicializa la UART0 del microcontrolador. Primero habilita la UART0 y el puerto A. Luego configura los registros de control de la UART para establecer la velocidad en baudios y otros parámetros como el número de bits de datos y el uso de FIFO. Finalmente, configura los pines del puerto A para su uso con la UART. La función `UART_Lee_dato` espera a que se reciba un dato en la UART y luego lo lee y lo almacena en la variable global `d_uint8Dato`. La función `UART0_Escribe_dato` espera a que el registro de transmisión de la UART esté vacío y luego escribe el dato pasado como argumento en él. La función `main` inicializa el reloj del sistema y llama a la función `UART_INI` para inicializar la UART. Luego entra en un bucle infinito donde lee un dato de la UART y luego lo escribe de nuevo en la UART.  |
