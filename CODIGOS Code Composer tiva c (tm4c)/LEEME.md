| Nombre del proyecto | Descripción de funcionamiento |
|---|---|
| # Cronometro.asm | Este código en lenguaje ensamblador para la Tiva C modelo tm4c1294ncpdt está diseñado para controlar un display de 16x2 utilizando los puertos K y M de la tarjeta. El código comienza configurando los puertos K y M como salidas digitales accediendo a los registros RCGCGPIO y PRGPIO para habilitar el reloj en los puertos y luego a los registros GPIODIR y GPIODEN para establecer la dirección de los puertos como salida y habilitar la función digital de los puertos. Luego, se envían comandos al display para encenderlo y restablecerlo utilizando el registro de datos en la dirección 0x4006.13FC. Los comandos son enviados en formato de 4 bits utilizando la subrutina 'pulsc' para generar un pulso en el pin E del display. Después de esto, el código envía datos al display para mostrar el mensaje "TE AMO BOLA". Cada carácter del mensaje se envía al registro de datos en formato ASCII y luego se llama a la subrutina 'puls' para generar un pulso en el pin E del display e ingresar el dato. El código también define varias subrutinas. Las subrutinas 'ret1s' y 'ret2s' son subrutinas de retardo que utilizan un bucle para consumir tiempo. Las subrutinas 'puls' y 'pulsc' generan pulsos en el pin E del display para ingresar datos y comandos, respectivamente. La diferencia entre ambas subrutinas es el estado del pin RS del display, que se establece en 1 para ingresar datos y en 0 para ingresar comandos. |
| # Ejemplo.asm | Este código está escrito en lenguaje ensamblador para el microcontrolador Tiva C modelo TM4C1294NCPDT. El código muestra cómo se pueden utilizar instrucciones básicas como `mov`, `movt`, `add` y `str` para realizar operaciones con registros y memoria. En la primera parte del código, se muestra la sintaxis básica de un programa en lenguaje ensamblador y cómo se pueden utilizar las directivas `.global`, `.data` y `.text` para definir el inicio del programa y las secciones de datos y código. También se muestra cómo utilizar la instrucción `mov` para mover valores a registros y la instrucción `movt` para mover solo la parte alta de un registro sin modificar la parte baja. En la segunda parte del código, se muestra cómo se pueden realizar operaciones de suma con la instrucción `add` y cómo utilizar las instrucciones `mov`, `movt` y `str` para mover valores a registros y almacenar valores en memoria. También se muestra cómo utilizar la instrucción `b` para realizar un salto incondicional a una etiqueta específica. |
| # Tiempo.asm | Este código está escrito en lenguaje ensamblador para una Tiva C modelo tm4c1294ncpdt y se utiliza para controlar un display LCD 16X2. El código comienza definiendo algunas constantes para su uso con bits de control y luego procede a habilitar los puertos K y M. Luego configura el puerto K como salida en todos los bits y lo configura como digital en todos los bits. Finalmente, apaga todos los bits M2-M0 del puerto M y lo configura como salida en los bits M2-M0. Después de configurar los puertos, el código llama a una subrutina llamada `iniciodisplay` para iniciar el display LCD. Esta subrutina envía varios comandos al display para configurarlo y luego espera un tiempo específico después de cada comando. Por ejemplo, envía el comando 0x0F para encender el display y luego espera 20 ms antes de enviar el siguiente comando. Una vez que el display está iniciado, el código escribe la palabra "Tiempo" en el display utilizando una serie de llamadas a subrutinas para escribir cada carácter individualmente. Luego entra en un bucle infinito donde llama a una subrutina llamada `cronos` para mostrar el tiempo en el display. Esta subrutina recupera el valor del tiempo y luego lo desplaza hacia la derecha para obtener el valor de las decenas. Luego suma 0x30 para convertirlo en un valor ASCII y lo escribe en el display. Después de eso, recupera el valor del tiempo nuevamente y lo enmascara para obtener solo el valor de las unidades. Luego suma 0x30 para convertirlo en un valor ASCII y lo escribe en el display. Finalmente, el código espera un tiempo y luego suma 1 al tiempo y verifica si ha alcanzado 100. Si es así, sale de la subrutina; de lo contrario, vuelve a mostrar el tiempo en el display. El código también contiene varias subrutinas adicionales que se utilizan para manipular los puertos K y M, esperar un tiempo específico y escribir comandos o datos en el display. Por ejemplo, la subrutina `pul_en` lee el valor del puerto M y luego realiza una operación lógica OR con el valor `benable` para activar el bit enable. Luego espera más de 450 ns y finalmente desactiva el bit enable utilizando una operación lógica BIC. En resumen, este código controla un display LCD 16X2 utilizando una Tiva C modelo tm4c1294ncpdt. Configura los puertos necesarios, inicia el display y luego muestra la palabra "Tiempo" seguida del tiempo actual en un bucle infinito. |
| # nuevo.asm | Este código está escrito en lenguaje ensamblador para el microcontrolador Tiva C modelo TM4C1294NCPDT y está diseñado para controlar un LCD 16X2. El código comienza con la configuración inicial de los puertos PORTK y PORTM y la definición de algunas constantes para su uso con bits de control. Luego, se enciende el display y se inicializa mediante una serie de pasos que incluyen la escritura de comandos y datos al display. El código también incluye una serie de subrutinas para realizar retardos de diferentes duraciones, como 450 nanosegundos, 1 segundo y 20 milisegundos. Estas subrutinas se utilizan en diferentes partes del código para asegurar que se cumplan los tiempos mínimos requeridos por el display. Además, hay varias subrutinas que realizan operaciones en los puertos PORTK y PORTM, como escribir datos en los puertos y activar o desactivar ciertos bits. También hay subrutinas para escribir comandos y datos al display utilizando los registros R6 o R2 como registros de datos. El código también incluye una subrutina llamada "compararNumero" (y su variante "compararNumero2") que convierte un número hexadecimal por encima de 9 a su equivalente en decimal. Esta subrutina se utiliza para ajustar el tiempo en formato decimal y escribirlo en el display.  El código escribe la palabra “Tiempo” en el display y luego despliega el tiempo, que comienza en 0. Hay una serie de instrucciones para convertir el tiempo a ASCII y escribirlo en el display. El tiempo se incrementa en 1 y se verifica si es igual a 99. Si es así, se salta a la etiqueta “alto”. |
| # prender.asm | Este código está escrito en lenguaje ensamblador para una Tiva C modelo tm4c1294ncpdt y su función es controlar un display utilizando los puertos PORTK y PORTM. En la primera parte del código, se habilitan los puertos PORTM y PORTK en los bits 11 y 9 respectivamente del registro RCGCGPIO. Luego, se verifica la habilitación de ambos puertos y se apagan todos los bits de los puertos K y M. Finalmente, se configuran los puertos PORTK y PORTM como salida en todos los bits. En la segunda parte del código, se configuran los puertos PORTK y PORTM como digitales en todos los bits. Luego, se inicializa la pantalla y se modifican los registros M para enviar información a la RAM y leer información de la memoria RAM. En la tercera parte del código, se encienden los números del 0 al 9 en el display utilizando una subrutina llamada `ret1s` para esperar un segundo entre cada número. Luego, el código entra en un bucle infinito y vuelve a encender los números del 0 al 9 en el display. La subrutina `ret1s` utiliza un contador para esperar un segundo antes de volver a la rutina principal. El bucle infinito al final del código permite que el programa siga encendiendo los números del 0 al 9 en el display indefinidamente. En resumen, este código controla un display utilizando los puertos PORTK y PORTM de una Tiva C modelo tm4c1294ncpdt para encender los números del 0 al 9 en el display con un intervalo de un segundo entre cada número. |
| # seriefibonachi.asm | Este código es un programa en lenguaje ensamblador para un procesador ARM que calcula la serie de Fibonacci. El programa almacena los dos primeros valores de la serie (0 y 1) en dos localidades de memoria específicas y luego entra en un bucle infinito donde carga estos valores, los suma y almacena el resultado en una nueva localidad de memoria. Este resultado se convierte en el siguiente valor de la serie de Fibonacci. El código comienza definiendo las secciones `.data` y `.text`, que son típicas en programas en lenguaje ensamblador. La sección `.data` se utiliza para declarar variables y la sección `.text` para el código del programa.b Luego, el código proporciona comentarios sobre cómo funcionan las instrucciones `STR` y `LDR`, que se utilizan para almacenar y cargar valores en la memoria. La instrucción `STR` almacena el valor de un registro en una localidad de memoria especificada por otro registro. La instrucción `LDR` carga el valor de una localidad de memoria especificada por un registro en otro registro. Después de estos comentarios, el código comienza a ejecutarse en la etiqueta `main`. Primero, se inicializa el registro `r7` con el valor `0x2000.1000`, que es la dirección de la primera localidad de memoria donde se almacenará el primer valor de la serie de Fibonacci (0). Luego, se inicializa el registro `r3` con el valor `0x00` y se utiliza la instrucción `STR` para almacenar este valor en la localidad de memoria especificada por `r7`. A continuación, se inicializa el registro `r6` con el valor `0x2000.1004`, que es la dirección de la segunda localidad de memoria donde se almacenará el segundo valor de la serie de Fibonacci (1). Se inicializa el registro `r3` con el valor `0x01` y se utiliza la instrucción `STR` para almacenar este valor en la localidad de memoria especificada por `r6`. Después de almacenar estos valores iniciales, el código entra en un bucle infinito etiquetado como `genf`. Dentro de este bucle, se cargan los valores almacenados en las localidades de memoria especificadas por los registros `r7` y `r6` utilizando las instrucciones `LDR`. Estos valores se suman y se almacenan en una nueva localidad de memoria especificada por el registro `r6`. Este resultado es el siguiente valor de la serie de Fibonacci. Luego, los registros `r6` y `r7` se incrementan en 4 para apuntar a las siguientes localidades de memoria y el bucle comienza de nuevo. |

