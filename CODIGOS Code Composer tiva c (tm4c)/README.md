| Nombre del proyecto | Descripción de funcionamiento |
|---|---|
| Cronometro.asm | This assembly language code for the Tiva C model tm4c1294ncpdt is designed to drive a 16x2 display using the K and M ports of the card. The code begins by configuring the K and M ports as digital outputs by accessing the RCGCGPIO and PRGPIO registers to enable clocking on the ports and then the GPIODIR and GPIODEN registers to set the address of the ports as output and enable the digital function of the ports. ports. Commands are then sent to the display to turn it on and reset it using the data register at address 0x4006.13FC. Commands are sent in 4-bit format using the 'pulsc' subroutine to generate a pulse on pin E of the display. After this, the code sends data to the display to show the message "I LOVE YOU BALL". Each character of the message is sent to the data register in ASCII format and then the 'puls' subroutine is called to generate a pulse on pin E of the display and input the data. The code also defines several subroutines. The 'ret1s' and 'ret2s' subroutines are delay subroutines that use a loop to consume time. The 'puls' and 'pulsc' subroutines generate pulses on pin E of the display to enter data and commands, respectively. The difference between both subroutines is the status of the RS pin of the display, which is set to 1 to enter data and 0 to enter commands.|
| Ejemplo.asm | This code is written in assembly language for the Tiva C microcontroller model TM4C1294NCPDT. The code shows how basic instructions such as `mov`, `movt`, `add` and `str` can be used to perform operations on registers and memory. The first part of the code shows the basic syntax of an assembly language program and how the `.global`, `.data`, and `.text` directives can be used to define the program startup and data sections. and code. It also shows how to use the `mov` statement to move values into registers and the `movt` statement to move only the top of a record without changing the bottom. The second part of the code shows how addition operations can be performed with the `add` statement and how to use the `mov`, `movt`, and `str` statements to move values into registers and store values in memory. It also shows how to use the `b` statement to make an unconditional jump to a specific label. |
| Tiempo.asm | This code is written in assembly language for a Tiva C model tm4c1294ncpdt and is used to control a 16X2 LCD display. The code starts by defining some constants for use with control bits and then proceeds to enable ports K and M. It then sets port K to output on all bits and sets it to digital on all bits. Finally, it turns off all the M2-M0 bits of the M port and sets it to output on the M2-M0 bits. After configuring the ports, the code calls a subroutine called `startdisplay` to start the LCD display. This subroutine sends several commands to the display to configure it, and then waits for a specific amount of time after each command. For example, it sends the command 0x0F to turn on the display, and then waits 20 ms before sending the next command. Once the display is started, the code writes the word "Time" to the display using a series of subroutine calls to write each character individually. It then goes into an infinite loop where it calls a subroutine called `chronos` to show the time on the display. This subroutine retrieves the time value and then shifts it to the right to get the tens value. It then adds 0x30 to convert it to an ASCII value and writes it to the display. After that, it retrieves the time value again and masks it to only get the units value. It then adds 0x30 to convert it to an ASCII value and writes it to the display. Finally, the code waits for a while and then adds 1 to the time and checks if it has reached 100. If so, it exits the subroutine; otherwise, it shows the time on the display again. The code also contains several additional subroutines that are used to manipulate the K and M ports, wait for a specified time, and write commands or data to the display. For example, the `pul_en` subroutine reads the value of port M and then performs a logical OR operation on the `benable` value to set the enable bit. It then waits for more than 450 ns and finally clears the enable bit using a BIC logic operation. In short, this code controls a 16X2 LCD display using a Tiva C model tm4c1294ncpdt. It configures the necessary ports, starts the display, and then shows the word "Time" followed by the current time in an infinite loop. |
| nuevo.asm | This code is written in assembly language for the Tiva C microcontroller model TM4C1294NCPDT and is designed to drive a 16X2 LCD. The code starts with the initial configuration of the PORTK and PORTM ports and the definition of some constants for use with check bits. The display is then powered on and initialized through a series of steps that includes writing commands and data to the display. The code also includes a number of subroutines to perform delays of different durations, such as 450 nanoseconds, 1 second, and 20 milliseconds. These subroutines are used in different parts of the code to ensure that the minimum times required by the display are met. In addition, there are several subroutines that perform operations on the PORTK and PORTM ports, such as writing data to the ports and turning certain bits on or off. There are also subroutines for writing commands and data to the display using registers R6 or R2 as data registers. The code also includes a subroutine called "compareNumber" (and its variant "compareNumber2") that converts a hexadecimal number above 9 to its decimal equivalent. This subroutine is used to set the time in decimal format and write it to the display. The code writes the word “Time” to the display and then displays the time, which starts at 0. There are a series of instructions to convert the time to ASCII and write it to the display. The time is incremented by 1 and checked to see if it equals 99. If so, it skips to the "stop" label. |
| prender.asm | This code is written in assembly language for a Tiva C model tm4c1294ncpdt and its function is to control a display using the PORTK and PORTM ports. In the first part of the code, the PORTM and PORTK ports are enabled in bits 11 and 9 respectively of the RCGCGPIO register. Then, the enable of both ports is verified and all bits of ports K and M are turned off. Finally, ports PORTK and PORTM are configured as output on all bits. In the second part of the code, the ports PORTK and PORTM are configured as digital in all bits. Then the display is initialized and the M registers are modified to send information to RAM and read information from RAM. In the third part of the code, the numbers 0 through 9 are turned on the display using a subroutine called `ret1s` to wait one second between each number. The code then goes into an infinite loop and turns the numbers 0-9 back on the display. The `ret1s` subroutine uses a timer to wait for one second before returning to the main routine. The infinite loop at the end of the code allows the program to keep flashing the numbers 0 through 9 on the display indefinitely. In summary, this code controls a display using the PORTK and PORTM ports of a Tiva C model tm4c1294ncpdt to turn on the numbers 0-9 on the display with a one second interval between each number. |
| seriefibonachi.asm | This code is an assembly language program for an ARM processor that calculates the Fibonacci series. The program stores the first two values of the string (0 and 1) in two specific memory locations and then enters an infinite loop where it loads these values, adds them, and stores the result in a new memory location. This result becomes the next value in the Fibonacci series. The code begins by defining the `.data` and `.text` sections, which are typical of assembly language programs. The `.data` section is used to declare variables and the `.text` section for program code.b The code then provides feedback on how the `STR` and `LDR` instructions work, which are used to store and load values into memory. The `STR` instruction stores the value of a register in a memory location specified by another register. The `LDR` instruction loads the value of a memory location specified by one register into another register. After these comments, the code starts executing at the `main` tag. First, register `r7` is initialized with the value `0x2000.1000`, which is the address of the first memory location where the first value of the Fibonacci series (0) will be stored. Then register `r3` is initialized with the value `0x00` and the `STR` instruction is used to store this value in the memory location specified by `r7`. Next, register `r6` is initialized with the value `0x2000.1004`, which is the address of the second memory location where the second value of the Fibonacci series (1) will be stored. Register `r3` is initialized with the value `0x01` and the `STR` instruction is used to store this value in the memory location specified by `r6`. After storing these initial values, the code enters an infinite loop labeled `genf`. Within this loop, the values stored in the memory locations specified by the `r7` and `r6` registers are loaded using the `LDR` instructions. These values are added together and stored in a new memory location specified by register `r6`. This result is the next value in the Fibonacci series. Then registers `r6` and `r7` are incremented by 4 to point to the next memory locations and the loop starts again. |
